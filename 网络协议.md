# 网络基础

## ISO

|    各层    |             说明             |
| :--------: | :--------------------------: |
|   应用层   |      为应用程序提供服务      |
|   表示层   |      数据格式转化、加密      |
|   会话层   |     简历、管理、维护会话     |
|   传输层   | 简历、管理、维护端到端的连接 |
|   网络层   |       IP选址及路由选择       |
| 数据链路层 |    提供截止访问和链路管理    |
|   物理层   |             硬件             |

### 物理层

1. 互联物理链路。物理介质（网线双绞线），光纤，无线电。实现基本的连接
2. 形式：电信号（二进制）、bit流
3. 比特流本身并无特别，为使其具有意义，数据链路层出现

### 数据链路层

1. 进行比特流的处理：分组——8位一组——字节，再按顺序发送——帧
2. MAC地址：标记网卡的物理地址，相当于网卡的身份证。请求或回应的报文中会标记源MAC和目标MAC

### 网络层

1. 获取对方MAC地址：ARP协议，通过IP地址解析MAC地址——地址解析
2. 判断通信双方是否在同一子网——IP协议
3. 选择多条路径中的最优路径：路由协议，是一组协议

### 传输层

1. 对发送数据进行封装一个个发送，以保证数据的完整性——TCP协议、UDP协议
2. 判断发送和回应的应用程序——定义端口的概念，通过端口寻找到对应的应用程序来进行数据的处理

### 会话层

1. 实现数据发送过程中网络断开等情况时可以从校验点继续回复数据进行重传（断点续传）
2. 自动收发、自动寻址

### 表示层

不同系统的语法并不相同

1. 提供一种公共语言来实现不同系统之间的通信

### 应用层

字节流形式的数据并不友好

1. 各种应用层协议规范数据格式。HTTP、HTTPS、FTP、DNS、TFTP、SMTO等



## TCP/IP四层模型

应用层（应用层、表示层、会话层）、传输层、网络层、数据链路层（数据链路层、物理层）



## 数据传输过程

主机A

​	https://www.baidu.com    应用层    应用程序数据

​	TCP头部 + https://www.baidu.com    传输层    TCP数据包

​	IP头部 + TCP头部 + https://www.baidu.com    网络层    IP数据包

​	源、目MAC地址 + IP头部 + TCP头部 + https://www.baidu.com    数据链路层    以太帧

​	bit流    物理层

↓

主机B

​	bit流    物理层

​	源、目MAC地址 + IP头部 + TCP头部 + https://www.baidu.com    数据链路层    以太帧

​	IP头部 + TCP头部 + https://www.baidu.com    网络层    IP数据包

​	TCP头部 + https://www.baidu.com    传输层    TCP数据包

​	https://www.baidu.com    应用层    应用程序数据

↓

主机B响应：

​	应用层→……

用信封来比喻：应用层内容相当于信件的内容；传输层相当于备注信件格式；网络层相当于信封上的地址；数据链路层MAC相当于收寄件人身份与联系方式。



## 网络层协议

### ARP协议

地址解析协议（address resolution protocol），实现通过IP地址或域名寻找MAC地址的功能

#### ARP协议的工作流程

1. 主机A首先查看自己的ARP表，如果找到了的主机B的MAXAC地址，则直接对IP数据包进行帧封装，发送给主机臣;
2. 如果主机A在ARP表中找不到主机B的MAC地址，则将缓存该数据报文，然后以**广播**方式发送一个ARP请求报文。ARP请求报文中带上**源IP地址和源MAC地址（主机A)**，目标IP地址和目标MAC地址为**主机B的IP地址和全0的MAC地址**。广播，该网段上的所有主机都可以接收到该请求，但**只有被请求的主机(即主机B）会对该请求进行处理**。
3. 主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理:将ARP请求报文中的发送端（即主机A)的IP地址和MAC地址存入自己的ARP表中。之后以**单播**方式发送ARP响应报文给主机A，其中包含了**自己的MAC地址**。
4. 主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。

ARP表：IP与MAC的对应表

### IP协议

Internet protocol：分配给用户上网使用网际协议的设备的数字标签，分为两大类——IPv4、IPv6

| IPv4                                              | IPv6                                |
| ------------------------------------------------- | ----------------------------------- |
| 32位二级制，表示时常把每8位之间隔开并各自转十进制 | 弥补IPv4地址池不够用的问题，有128位 |
|                                                   | 表示时用十六进制                    |

IP = 网络号 + 主机号，

1. 网络号用于标记一个子网，在同一个子网的主机可以直接通信

2. 子网掩码：用于表示子网，连续的1表示网络地址，连续的0表示主机地址

3. 查看子网掩码后看两主机的IP的网络号是否相同，相同即在一子网

   如192.168.1.87 255.255.255.0    主机A

   ​	193.168.2.77 255.255.255.0    主机B

   ​	两主机的网络号分别为192.168.1 和 193.168.2，不是同一子网，不能直接通信

### 路由协议和路由表

不在一个子网的两个主机的通信需要经过路由协议来完成

#### 路由协议

routing protocol，指定数据包转送方式的网上协议。是一组协议

| 静态路由                 | 动态路由                 | 默认路由                   |
| ------------------------ | ------------------------ | -------------------------- |
| 指定目的地址，指定下一跳 | RIP、OSPF、BGP           | 数据发到默认网关指定的地址 |
|                          | 配置之后动态学习路由条目 |                            |

#### 路由表

发送数据是查看路由表来知道路由的路径

1. 网络目标：目的地址
2. 网络掩码：目标所在的子网
3. 网关：下一跳的地址
4. 跃点数：相当于中间站数量，和优先级挂钩，跃点数越小，优先级越高
5. 在链路上：当前网卡直连的设备



## 传输层协议

### TCP协议

transmission control protocol，传输控制协议，即对数据的传输进行一定的控制

TCP协议头部组成：![image-20220713185834716](.\images\image-20220713185834716.png)

HTTP和HTTPS是基于TCP的应用层协议，TCP连接请求——TCP三次握手，TCP断开连接——TCP四次挥手

序号（sequence number）：即编号。当发送的数据比较大时，发送过程中需要对其进行分段，收到者需要对一个个片段进行重组，编号即用来对目前的数据包所在的位置进行编号。

确认号（acknowledge number）：服务器能够回应。存在于确认消息中，与序号的关系：确认号=序号+1，表示主机B期待收到的下一个包的序号。

标志位：状态控制码（code control flag）

- ACK位：即acknowledge，确认位，该位为1时表示消息是一条确认消息
- RST位：即reset，重置位，为1时表示消息是一条释放连接的消息。TCP连接出现错误时需要断开连接重新建立
- SYN位：synchronize，同部位，为1时表示消息是发起连接的消息或确认接收连接的消息
- FIN位：final，终止位，为1时表示发送报文结束了，该释放连接了，于是进行四次挥手

#### TCP三次握手

比喻：

A想认识B，于是跟B打了个招呼表示认识一下，B收到后回复确认收到了招呼并同一认识一下，A再发一个消息给B确认收到B的确认消息和同意的态度，于是两人开始愉快的玩耍。这个过程即三次握手。![image-20220713194840748](.\images\image-20220713194840748.png)

#### TCP四次挥手

A想和B绝交，于是A对B说要绝交，B先确认收到，然后B说其实我也想绝交，A再确认。![image-20220713195639162](.\images\image-20220713195639162.png)

### UDP协议

user datagram protocol，用户数据报协议

UDP协议头部结构![image-20220714191746337](.\images\image-20220714191746337.png)

UDP协议没有序号、确认号标志位等，并不会建立连接 → 无连接的传输协议 → 不可靠协议，允许出现丢包、出错；但是速度快，资源消耗小。

应用场景：不需要可靠的机制，值要求速度。如流媒体、IP电话、多媒体游戏

基于UDP的协议：DNS（域名解析协议默认使用UDP）、SNMP、DHCP（动态获取IP）

基于TCP的协议：HTTP、HTTPS、FTP

### TCP、UDP对比

| 特征点     | TCP          | UDP            |
| ---------- | ------------ | -------------- |
| 是否连接   | 面向连接     | 面向非连接     |
| 传输可靠性 | 可靠         | 会丢包，不可靠 |
| 应用场景   | 传输数据量大 | 传输量小       |
| 速度       | 慢           | 快             |

- TCP是面向连接的，所有TCP三次握手和四次挥手的过程;UDP无连接协议;
- TCP因为有可靠的连接机制==可靠协议;UDP没有连接和确认机制，==会丢包，会出错，不可靠的协议;TCP协议:数据量很大，防止丢包，正确重传;对数据正确性很关心;UDP:量小
- 速度:TCP协议速度很慢，传输效率低;UDP:速度很快，传输效率很高。



## 应用层协议

规范数据格式

### HTTP协议

Hyper text transfer protocol，超文本传输协议

- 基于TCP，默认端口80 —— 可靠的协议
- 功能：规范客户端和服务端的数据传输格式
- 特点：基于请求与相应模式、无状态、无连接的应用层协议

#### HTTP请求报文

##### 请求行

**请求方法 URL HTTP版本信息**

请求方法：

| 标识符   | 描述                                         |
| -------- | -------------------------------------------- |
| **GET**  | 请求读取由URL所标识的信息——获取资源和信息    |
| **POST** | 给服务器发数据——发送提交数据 （创建）        |
| HEAD     | 请求读取由URL所标识的信息的首部              |
| PUT      | 在指明的URL下存储一个文档——restful——替换资源 |
| DELETE   | 删除指明的URL所标识的资源                    |
| CONNECT  | 用于代理服务器                               |
| OPTION   | 请求一些选项的信息                           |
| TRACE    | 用来进行环回测试的请求报文                   |

##### 请求头部

| 字段             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| **User_Agent**   | 产生请求的客户端类型。系统类型、浏览器版本（内核）、反爬虫机制 |
| **Accept**       | 客户端可以识别的内容类型列表                                 |
| **Host**         | 请求的主机名，允许多个域名用一个IP地址（虚拟主机）           |
| Accept-Encoding  | 客户端使用的编码环境、编码方式                               |
| Accept-Language  | 客户端语言环境                                               |
| Authorization    | 授权信息，一般用于存放授权之后的信息                         |
| Authentication   | 客户端提供给服务器进行权限认证的信息                         |
| Connection       | 表示是否需要持久连接                                         |
| Content-Length   | 表示数据正文的长度                                           |
| **Cookie**       | 存储保持会话的重要信息                                       |
| Referer          | 表示该次请求的来源，一般用于做防盗链                         |
| **content-type** | 传给服务器的内容的类型和字符集                               |
| Content-length   | 请求体的数据长度（GET请求一般没有请求体）                    |
| Cache-control    | 缓存机制：Cache-control: no chach                            |
| Pragma           | 方式页面被缓存，和Cache-control: no chach效果一样            |

#### HTTP响应报文

##### 响应行

第一行HTTP版本 + HTTP状态码 + 原因描述

- ​	HTTP状态码：

  ​		1xx - 接收的请求正在被处理

  ​		2xx - 请求正常处理完毕

  ​		3xx - 重定向

  ​		4xx - 客户端的问题导致出错

  ​		5xx - 服务器问题导致出错

##### 响应头部

| 字段名          | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| Server          | http服务器的软件信息                                         |
| Date            | 相应报文的时间                                               |
| Expires         | 指定缓存过期的时间                                           |
| **Set-Cookies** | 设置cookies，服务器返回的文本                                |
| Last-modify     | 资源最后修改的时间                                           |
| Content-type    | 响应的类型和字符集                                           |
| Content-length  | 内容长度                                                     |
| **Connection**  | 一般都是keep-alive，保持TCP连接不关闭，但是不会长久保持连接，服务器可设置 |
| Location        | 指定重定向的设置，新的URL地址                                |
| ……              |                                                              |

##### 响应正文（响应体）

返回的页面的编码

#### HTTP协议特点

##### 无连接应用协议

- 限制每次连接只处理一个请求
- 服务器处理完客户的请求，并收到客户的应答后即断开连接

设计初衷：用户量很大，单个用户间歇性打，数据没有关联性，连接保持的话会有很大的浪费。

同时也出现了一些问题：网页愈加复杂，可能一次发不完需要多次建立释放连接，传输效率降低，于是在Connection: keep-alive

Keep-alive设置：

- 开启：会发起Keep-alive的连接请求——长连接。在HTTP1.1中是默认打开的 —— 不需要重新建立连接

- 关闭：在http头部中设置Connection: close

- 设置连接时间：

  ​	在http头部中设置Keep-alive: timeout=5,max=1000

  ​		timeout->超时时间，单位秒，超过这个时间后断开连接

  ​		max->最多连接次数，超过即强制断开

##### 无状态应用协议

- 对事物处理没有记忆能力，服务器不知道客户端的状态；给服务器发送HTTP请求之后，服务器回应之后不会有任何记录

- 每个请求独立

  服务器处理后续请求中用到前面请求过的信息仍需要重传

  优点：释放了服务器的压力

  缺点：每次用到时都需要重传，增大数据传输量 —— cookies和session来解决

- cookies：将前面请求信息保存成一个临时文件保存在浏览器 ——cookies

  如登录、充值。登录时把登录的账号信息保存在cookie值中

  但是关闭浏览器时会被删除，清楚历史

- session：相当于永久的cookies值。session ID（会话编号） ——保存在服务器内存中

  有一定的资源占用问题。可以设置session超时时间，超时即删

#### HTTP缺点->安全隐患

- 发送数据都是文明的
- 第三者窃听？截取、篡改数据包？伪装客户端？
- 没有机制确认双方身份

↓

### HTTPS协议

hypertext transfer protocol secure，超文本传输安全协议，是以安全为目标的HTTP通道，即HTTP的安全版。加密数据并确保其机密性（加密），可以保护用户在与网站交互时免于窃取个人信息和计费数据（身份认证，防止篡改）

HTTPS报文结构：![image-20220715110551035](.\images\image-20220715110551035.png)

SSL/TLS：用户保障安全

HTTP + 加密 + 身份认证 + 完整性保护 = HTTP + SSL = HTTPS

#### SSH握手过程

1. 客户端请求建立SSL连接并将自己支持的一套加密规则发送给服务器。

2. 网站从众选出一组加密算法与hash算法，并将自己的身份信息以证书的形式发回给浏览器。帧数里面包含了网站地址，加密公钥，以及证书的颁发机构等。

3. 获得网站证书之后的浏览器的工作：

   1 验证证书的合法性-服务器身份，如证书受信任，浏览器会生成一串随机数密码，并用证书中提供的公钥加密

   2 把密码发给网站

   3 告诉网站后续报文要加密了，握手结束

4. 网站接收浏览器发来的数据之后的操作：

   1 使用自己的秘钥将信息解码

   2 告诉客户端后续报文要加密了

公钥：一般用来进行加密。私钥：一般用来解密

问题：加密方式是对称的，如果第三方知道了所使用的加密算法，那么仍然不安全。

↓

非对称加密→TLS

#### TLS

对称和非对称都有用到，建立连接时使用非对称，而之后的交互中使用非对称

- 非对称加密：

  双方各自有自己的私钥，然后约定使用同一种公钥加密，数据经过公钥的加密后只能用私钥解密。

  服务器中有成对的公钥和私钥，公布公钥。客户端或第三端用公钥对报文加密后用公钥无法解密。

#### TLS握手过程

![image-20220715114444274](.\images\image-20220715114444274.png)

Ending……
